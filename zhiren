#!/bin/bash
# Zhiren - Autonomous AI development system
#
# Commands:
#   zhiren refresh <notes.md>       - Add tasks from freeform notes
#   zhiren task [opts] "desc"       - Run isolated single-task mode
#   zhiren [opts] [n]               - Run n iterations (default 25)
#   zhiren --rebuild                - Force rebuild Docker image (safe mode only)
#   zhiren --disable-auto-update    - Disable automatic update checks
#   zhiren --enable-auto-update     - Re-enable automatic update checks
#
# Main loop options:
#   --batch             - Enable batch mode (up to 5 related tasks per iteration)
#   --batch=N, -bN      - Enable batch mode with custom size (up to N tasks)
#                         Tasks are grouped by natural relatedness, not forced
#
# Task mode options:
#   --safe              - Run in Docker container
#   -f, --file <file>   - Read task description from file
#   --branch <name>     - Use custom branch name
#   --no-pr             - Skip PR creation
#   -n <num>            - Max iterations (default 25)
#
# Safe mode (--safe): Runs Claude in a Docker container that can only access
# the project directory. Use for unattended runs to prevent accidental
# damage to other files on the system.
#
# Loop: PLAN ‚Üí EXECUTE ‚Üí REVIEW ‚Üí FIX
#
# Task mode: Isolated single-task fixes. Does NOT touch CONTEXT.md, TASKS.md.
# Uses .zhiren/tasks/<task-id>/ for state. Auto-creates branch and PR if git/gh available.
#
# idea.md/notes.md are freeform - write whatever you want. Zhiren will figure it out.

# -e: ÂëΩ‰ª§Â§±Ë¥•Êó∂Á´ãÂç≥ÈÄÄÂá∫
# -u: ‰ΩøÁî®Êú™ÂÆö‰πâÂèòÈáèÊó∂Êä•Èîô
set -eu

SCRIPT_DIR="$(dirname "${BASH_SOURCE[0]}")"

# Instance-specific temp folder for verbose command output
# Uses PID + timestamp for uniqueness across concurrent instances
ZHIREN_INSTANCE_ID="$$_$(date +%s)"
ZHIREN_TMP_DIR="/tmp/zhiren-${ZHIREN_INSTANCE_ID}"
export ZHIREN_TMP_DIR

# Âú∫ÊôØ
export ZHIREN_EXECUTE_SCENE=""

# Source library components
source "$SCRIPT_DIR/lib/tools.sh"
source "$SCRIPT_DIR/lib/consts.sh"
source "$SCRIPT_DIR/lib/date_utils.sh"

# ÂΩìÂâçÊâßË°åÁöÑÊ≠•È™§ËÆ∞ÂΩïÊñá‰ª∂
ZHIREN_CURRENT_STEP_FILE="${PROJECT_ZHIREN_DIR}/zhiren_current_step"

# Source library components
source "$SCRIPT_DIR/lib/log.sh"
source "$SCRIPT_DIR/lib/prompts.sh"
source "$SCRIPT_DIR/lib/task_manager.sh"
source "$SCRIPT_DIR/lib/safe_mode.sh"
source "$SCRIPT_DIR/lib/claude.sh"

log "LIGHT" "üöÄ Starting Zhiren script..."

source "$SCRIPT_DIR/lib/session_manager.sh"

log "INFO" "ZHIREN_EXECUTE_SCENE=$ZHIREN_EXECUTE_SCENE"
log "INFO" "SCRIPT_DIR=$SCRIPT_DIR"
log "INFO" "ZHIREN_HOME=$ZHIREN_HOME"
log "INFO" "ZHIREN_PROJECT_ROOT=$ZHIREN_PROJECT_ROOT"
log "INFO" "LOG_DIR=$LOG_DIR"
log "INFO" "LOG_FILE=$LOG_FILE"
log "INFO" "ZHIREN_TMP_DIR=$ZHIREN_TMP_DIR"
log "INFO" "ZHIREN_CLAUDE_SESSION_FILE=$ZHIREN_CLAUDE_SESSION_FILE"
log "INFO" "CURRENT_TASK_FILE_PATH=$CURRENT_TASK_FILE_PATH"
log "INFO" ""

# Instance-specific temp folder for verbose command output
mkdir -p "$ZHIREN_TMP_DIR"

# Cleanup function for temp folder
cleanup_temp() {
    if [[ -d "$ZHIREN_TMP_DIR" ]]; then
        rm -rf "$ZHIREN_TMP_DIR"
    fi
}

# Trap signals to ensure cleanup on exit (normal, interrupt, terminate)
# INT: Áî®Êà∑Êåâ‰∏ã Ctrl+C Êó∂ÂèëÈÄÅÁöÑ‰∏≠Êñ≠‰ø°Âè∑ÔºåÂíåSIGINTÁ≠âÂêå„ÄÇ
# TERM: Á≥ªÁªüÂèëÈÄÅÁöÑÁªàÊ≠¢‰ø°Âè∑ÔºàÂ¶Ç kill ÂëΩ‰ª§ÔºâÔºåÂíåSIGTERMÁ≠âÂêå„ÄÇ
# EXIT: ÊòØ‰º™‰ø°Âè∑Ôºå‰ªÖÂú®ËÑöÊú¨ÈÄÄÂá∫Êó∂Ëß¶ÂèëÔºàÊó†ËÆ∫ÊòØÊ≠£Â∏∏ÈÄÄÂá∫ËøòÊòØË¢´‰ø°Âè∑‰∏≠Êñ≠ÔºâÔºå‰ºöÊçïËé∑‰ª•‰∏ãÊâÄÊúâÊÉÖÂÜµÔºö
#   1. ËÑöÊú¨Ê≠£Â∏∏ÊâßË°åÁªìÊùü
#   2. exit ÂëΩ‰ª§
#   3. ‰ªª‰Ωï‰ø°Âè∑ÂØºËá¥ÁöÑÈÄÄÂá∫
#   4. ËÑöÊú¨‰∏≠‰ªª‰ΩïÈîôËØØÔºàÂ¶ÇÊûúÊúâset -eÔºâ
trap cleanup_temp EXIT INT TERM

# Safe mode (Docker) settings
SAFE_MODE=false

INNER_RUN_CLAUDE_FIRST_RUN=true
inner_run_claude() {
    local user_prompt="$1"
    local phase="$2"
    local loop_count="${3:-}"
    local session_id=$(get_claude_session_id)
    local session_is_new=""

    if [[ "$INNER_RUN_CLAUDE_FIRST_RUN" == "true" ]]; then
        # È¶ñÊ¨°ËøêË°åÔºåÂàùÂßãÂåñ
        session_is_new=$(get_claude_session_is_new)
        INNER_RUN_CLAUDE_FIRST_RUN=false
    else
        # ÂêéÁª≠ËøêË°åÔºåsessionÂ∑≤Â≠òÂú®
        session_is_new="false"
    fi

    run_claude "user_prompt" "$user_prompt" \
        "phase" "$phase" \
        "session_is_new" "$session_is_new" \
        "session_id" "$session_id" \
        "save_mode" "$SAFE_MODE" \
        "loop_count" "$loop_count"
    local claude_exit_code=$?
    if [[ $claude_exit_code -eq 0 ]]; then
        return 0
    fi

    log "ERROR" "[$phase] Claude failed, exit code $claude_exit_code"
    exit $claude_exit_code
}

#==============================================================================
# PROMPTS - Defined early so both task mode and main loop can use them
#==============================================================================

PLAN_PROMPT=$(get_plan_prompt)
EXECUTE_PROMPT=$(get_execute_prompt)
REVIEW_PROMPT=$(get_review_prompt)
FIX_PROMPT=$(get_fix_prompt)


#==============================================================================
# GIT/GH DETECTION FUNCTIONS (for task command)
#==============================================================================

# Detect if git is available and we're in a repo
detect_git() {
    if command -v git &>/dev/null && git rev-parse --git-dir &>/dev/null 2>&1; then
        echo "1"
    else
        echo "0"
    fi
}

# Detect if gh CLI is available and authenticated
detect_gh() {
    if command -v gh &>/dev/null && gh auth status &>/dev/null 2>&1; then
        echo "1"
    else
        echo "0"
    fi
}

# Generate task ID from description (uses first line only for slug)
generate_task_id() {
    local description="$1"
    local timestamp=$(date +%s)
    # Use only first non-empty line for slug (handles multi-line markdown)
    local first_line=$(echo "$description" | grep -v '^#' | grep -v '^$' | head -1)
    local slug=$(echo "$first_line" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | cut -c1-30)
    echo "${timestamp}-${slug}"
}

#==============================================================================
# REBUILD COMMAND - Force rebuild Docker image
#==============================================================================
if [[ "${1:-}" == "--rebuild" ]]; then
    SAFE_MODE=$(detect_safe_mode)

    if [[ "$SAFE_MODE" != true ]]; then
        log "ERROR" "Error: Not a safe mode project (no $SAFE_MODE_DOCKERFILE found)"
        log "ERROR" "Run 'zhiren init --safe <idea.md>' to enable safe mode"
        exit 1
    fi

    log "LIGHT" "Rebuilding Docker image..."
    build_docker_image "true"
    exit 0
fi

refresh_tasks() {
    local notes_file="$1"

    if [[ -z "$notes_file" ]]; then
        log "ERROR" "Usage: zhiren refresh <notes.md>"
        exit 1
    fi

    if [[ ! -f "$notes_file" ]]; then
        log "ERROR" "Error: $notes_file not found"
        exit 1
    fi

    if [[ ! -f "$CONTEXT_FILE" ]]; then
        log "ERROR" "Error: $CONTEXT_FILE not found - run 'zhiren init' first"
        exit 1
    fi

    if [[ ! -f "$TASK_FILE" ]]; then
        log "ERROR" "Error: $TASK_FILE not found - run 'zhiren init' first"
        exit 1
    fi

    log "LIGHT" "Zhiren refreshing project from: $notes_file"

    REFRESH_PROMPT=$(cat "${SCRIPT_DIR}/resources/prompt_refresh.md")

    NOTES_CONTENT=$(cat "$notes_file")
    CONTEXT_CONTENT=$(cat "$CONTEXT_FILE")
    TASKS_CONTENT=$(cat "$TASK_FILE")

    # Read CLAUDE.md if exists
    CLAUDE_MD=""
    if [[ -f "CLAUDE.md" ]]; then
        CLAUDE_MD="
## Project Rules (from CLAUDE.md):
$(cat CLAUDE.md)
"
    fi

    inner_run_claude "# USER'S NOTES:

$NOTES_CONTENT

---

## CURRENT CONTEXT.md:
$CONTEXT_CONTENT

---

## CURRENT TASKS.md:
$TASKS_CONTENT

$CLAUDE_MD
---

$REFRESH_PROMPT" "REFRESH"

    # Show result
    NEW_TASKS=$(grep -c '^\s*- \[ \]' "$TASK_FILE" | xargs 2>/dev/null || echo "0")
    log "SUCCESS" "Project refreshed!"
    log "INFO" "  - $NEW_TASKS pending tasks in $TASK_FILE"
    log "INFO" ""
    log "LIGHT" "Run 'zhiren' to work through the new tasks"
}

#==============================================================================
# REFRESH COMMAND - Add tasks from freeform notes
#==============================================================================
if [[ "${1:-}" == "refresh" ]]; then
    refresh_tasks "$2"

    exit 0
fi

# Only execute when run directly, not when sourced
if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then
    log "ERROR" "Error: zhiren script should be run directly, not sourced"
    exit 1
fi

#==============================================================================
# MAIN LOOP - PLAN ‚Üí EXECUTE ‚Üí REVIEW ‚Üí FIX
#==============================================================================

# Parse main loop arguments
MAX_ITERATIONS=
BATCH_MODE=false
BATCH_SIZE=5

while [[ $# -gt 0 ]]; do
    case "${1:-}" in
        --batch=*)
            # --batch=N syntax: batch mode with custom size
            BATCH_MODE=true
            BATCH_SIZE="${1#--batch=}"
            shift
            ;;
        --batch)
            # --batch alone: batch mode with default size
            BATCH_MODE=true
            shift
            ;;
        -b=*)
            # -b=N syntax: batch mode with custom size
            BATCH_MODE=true
            BATCH_SIZE="${1#-b=}"
            shift
            ;;
        -b[0-9]*)
            # -bN syntax (no space): batch mode with custom size
            BATCH_MODE=true
            BATCH_SIZE="${1#-b}"
            shift
            ;;
        -b)
            # -b alone: batch mode with default size
            BATCH_MODE=true
            shift
            ;;
        [0-9]*)
            MAX_ITERATIONS="$1"
            shift
            ;;
        *)
            log "ERROR" "Unknown option: $1"
            log "INFO" "Usage: zhiren [options] [iterations]"
            log "INFO" "Options:"
            log "INFO" "  --batch       Enable batch mode (up to 5 related tasks)"
            log "INFO" "  --batch=N     Enable batch mode with custom size"
            log "INFO" "  -b, -bN       Short form of --batch, --batch=N"
            exit 1
            ;;
    esac
done

# Check required files
if [[ ! -f "$TASK_FILE" ]]; then
    log "ERROR" "Error: $TASK_FILE not found"
    log "INFO" "Run 'zhiren init <idea.md>' first"
    exit 1
fi

# Determine max iterations if not set
if [ -z "$MAX_ITERATIONS" ]; then
    # Ê†πÊçÆ‰ªªÂä°Êï∞ÈáèÂä®ÊÄÅËÆæÁΩÆÊúÄÂ§ßËø≠‰ª£Ê¨°Êï∞
    log "INFO" "TASKS.md file path: $TASK_FILE"
    REMAINING=$(grep -c '^\s*- \[ \]' "$TASK_FILE" | xargs || echo "0")
    if [ "$REMAINING" -eq 0 ]; then
        MAX_ITERATIONS=1
        # Âæ™ÁéØÈáåÈù¢Ëøò‰ºöÂà§Êñ≠Ââ©‰Ωô‰ªªÂä°ÔºåËøôÈáåËÆæÁΩÆ1‰øùËØÅËÉΩËøõÂÖ•Âæ™ÁéØ‰∏ÄÊ¨°‰ª•ÊâìÂç∞ÂÆåÊàê‰ø°ÊÅØ
        log "WARN" "No remaining tasks - setting MAX_ITERATIONS to $MAX_ITERATIONS"
    else
        MAX_ITERATIONS=$((REMAINING * 2))
        log "LIGHT" "MAX_ITERATIONS not set - defaulting to $MAX_ITERATIONS (2x remaining tasks: $REMAINING)"
    fi
fi

if [[ ! -f "$CONTEXT_FILE" ]]; then
    log "WARNING" "Warning: $CONTEXT_FILE not found"
fi

# Main mode testing guidance (injected into context)
MAIN_MODE_HEADER="## Introduction
You are Zhiren, an autonomous AI development agent.

## DEVELOPMENT MODE - Testing Requirements
**Testing is CRITICAL for the feedback loop:**
- If no tests exist yet ‚Üí flag as üü° ISSUE: \"No tests - add test for this feature\"
- If tests exist but don't cover new code ‚Üí flag as üü° ISSUE: \"Add test coverage\"
- Tests let you VERIFY the implementation works - without them you're blind
- A feature without tests is not truly complete

"

# Load context fresh each iteration
load_context() {
    CONTEXT="$MAIN_MODE_HEADER"
    if [[ -f "$CONTEXT_FILE" ]]; then
        # CONTEXT+=$(cat "$CONTEXT_FILE")
        CONTEXT="$CONTEXT

---

## Context from CONTEXT.md
\`\`\`markdown
$(cat "$CONTEXT_FILE")
\`\`\`
"
    fi
    # Also include CLAUDE.md if exists (project rules)
    if [[ -f "CLAUDE.md" ]]; then
        CONTEXT="$CONTEXT

---

## Project Rules (from CLAUDE.md):
\`\`\`markdown
$(cat CLAUDE.md)"
\`\`\`
    fi

    CONTEXT="$CONTEXT

---

"
}

# Detect and setup safe mode if applicable
SAFE_MODE=$(detect_safe_mode)
if [[ "$SAFE_MODE" == true ]]; then
    log "LIGHT" "Safe mode detected (.zhiren/Dockerfile found)"
    build_docker_image "false"
    echo ""
fi

STEPS=("PLAN" "EXECUTE" "REVIEW" "FIX")
run_step() {
    local step_num="$1"
    local step_name="$2"
    local use_prompt="$3"
    local purpose="${4:-...}"
    local loop_count="${5:-}"

    log "INFO" "Save the current step:$step_name. File Path:$ZHIREN_CURRENT_STEP_FILE" >&2
    cat > "$ZHIREN_CURRENT_STEP_FILE" << EOF
{
    "step": "$step_name",
    "state": "Running"
}
EOF

    log "LIGHT3" "[${step_num}/4 ${step_name}] $purpose"
    if ! inner_run_claude "$use_prompt" "$step_name" "$loop_count"; then
        log "ERROR" "$step_name STEP failed after $MAX_RETRIES retries - aborting" >&2
        exit 1
    fi

    # PLAN Ê≠•È™§ÁöÑÁâπÊÆäÊ£ÄÊü•
    if [[ "$step_name" == "PLAN" ]]; then
        if [[ ! -f "$CURRENT_TASK_FILE_PATH" ]]; then
            log "ERROR" "PLAN STEP failed: No ${CURRENT_TASK_FILE_NAME} file found. File expected path: $CURRENT_TASK_FILE_PATH. Continuing with PLAN STEP."
            cat > "$ZHIREN_CURRENT_STEP_FILE" << EOF
{
    "step": "$step_name",
    "state": "Error",
    "errorCode": "TASK_NOT_GENERATED"
}
EOF
            return
        fi

        # ‰ªªÂä°ÂΩíÊ°£
        task_archiving "$CURRENT_TASK_FILE_PATH"
    fi

    local next_step=""
    # Ê≠•È™§Êï∞ÁªÑÊï∞Èáè
    local step_len=${#STEPS[@]}
    if [[ $step_num -ge $step_len ]]; then
        # ÂΩìÂâçÊ≠•È™§Êï∞Â§ß‰∫éÊ≠•È™§Êï∞ÁªÑÊï∞ÈáèÔºå‰∏ã‰∏Ä‰∏™Ê≠•È™§ÂøÖÈ°ªÊòØÊï∞ÁªÑÁöÑÁ¨¨‰∏Ä‰∏™ÂÖÉÁ¥†
        next_step="${STEPS[0]}"
    else
        # step_numÊòØÊï∞ÁªÑÁ¥¢Âºï+1ÔºåÊâÄ‰ª•‰∏ã‰∏Ä‰∏™Ê≠•È™§Áõ¥Êé•Â∞ÜÂÆÉÂΩìÂÅöÁ¥¢Âºï
        next_step="${STEPS[$step_num]}"
    fi
    log "INFO" "Save the next step:$next_step. File Path:$ZHIREN_CURRENT_STEP_FILE" >&2
    cat > "$ZHIREN_CURRENT_STEP_FILE" << EOF
{
    "step": "$step_name",
    "state": "Success",
    "nextStep": "$next_step"
}
EOF
}

find_step() {
    local target_step="$1"  # ‰ΩøÁî®Êõ¥ÊúâÊÑè‰πâÁöÑÂèòÈáèÂêç
    local index
    
    # echo "DEBUG: Looking for step: $target_step" >&2
    
    for index in "${!STEPS[@]}"; do
        # echo "DEBUG: Checking index $index: ${STEPS[$index]}" >&2
        if [[ "${STEPS[$index]}" == "$target_step" ]]; then
            # echo "DEBUG: Found at index $index" >&2
            echo "$index"
            return 0
        fi
    done
    
    # echo "DEBUG: Step '$target_step' not found" >&2
    echo "-1"
    # return 1
}

# Start main loop
main_loop() {
    local all_tasks_count=$(grep -c '^\s*- \[[ xX]\]' "$TASK_FILE" | xargs 2>/dev/null || echo "0")

    # Log session start
    log "INFO" "=== Zhiren session started ==="
    log "INFO" "Total tasks: $all_tasks_count, Max iterations: $MAX_ITERATIONS, Safe mode: $SAFE_MODE, Batch mode: $BATCH_MODE (size: $BATCH_SIZE)"
    log "INFO" "Working directory: $(pwd)"

    log "LIGHT" "Zhiren starting - max $MAX_ITERATIONS iterations"
    if [[ "$BATCH_MODE" == true ]]; then
        log "LIGHT" "Batch mode: up to $BATCH_SIZE related tasks per iteration"
    fi

    log "LIGHT" "Loop: PLAN ‚Üí EXECUTE ‚Üí REVIEW ‚Üí FIX."
    log "INFO" "Logs: $LOG_FILE"
    log "INFO" ""

    local i
    for i in $(seq 1 $MAX_ITERATIONS); do
        local current_step="PLAN"
        if [[ -s "$ZHIREN_CURRENT_STEP_FILE" ]]; then
            current_step=$(jq -r '
    if (.nextStep | length > 0) then 
        .nextStep 
    else 
        .step 
    end
' $ZHIREN_CURRENT_STEP_FILE)
        fi
        # ÊâæÂà∞Ëµ∑ÂßãÊ≠•È™§ÁöÑÁ¥¢Âºï
        local current_idx=$(find_step "$current_step")
        if [[ $current_idx -eq -1 ]]; then
            log "ERROR" "Êó†ÊïàÊ≠•È™§:$current_step"
            exit 1
        fi

        # Load context fresh each iteration
        load_context

        # Check for remaining tasks
        if ! grep -q '^\s*- \[ \]' "$TASK_FILE"; then
            log "SUCCESS" "All tasks complete!"
            rm -f "$CURRENT_TASK_FILE_PATH"
            exit 0
        fi

        # ËÆ°ÁÆóÂ∑≤ÂÆåÊàê‰ªªÂä°ÁôæÂàÜÊØîÔºå‰øùÁïô‰∏§‰ΩçÂ∞èÊï∞
        tasks_completed=$((all_tasks_count - REMAINING))
        tasks_completed_percent=$(awk -v c=$completed -v t=$total 'BEGIN {printf "%.2f", c/t*100}')

        REMAINING=$(grep -c '^\s*- \[ \]' "$TASK_FILE" | xargs || echo "0")
        log "LIGHT2" "=== Iteration $i/$MAX_ITERATIONS ($REMAINING of $all_tasks_count tasks remaining, $tasks_completed_percent complete). $current_step step. ==="

        # Select prompts based on batch mode
        if [[ "$BATCH_MODE" == true ]]; then
            ACTIVE_PLAN_PROMPT=$(get_batch_plan_prompt "$BATCH_SIZE")
            ACTIVE_EXECUTE_PROMPT=$(cat "${SCRIPT_DIR}/resources/prompt_batch_execute.md")
            ACTIVE_REVIEW_PROMPT=$(cat "${SCRIPT_DIR}/resources/prompt_batch_review.md")
            ACTIVE_FIX_PROMPT=$(cat "${SCRIPT_DIR}/resources/prompt_batch_fix.md")
        else
            ACTIVE_PLAN_PROMPT="$PLAN_PROMPT"
            ACTIVE_EXECUTE_PROMPT="$EXECUTE_PROMPT"
            ACTIVE_REVIEW_PROMPT="$REVIEW_PROMPT"
            ACTIVE_FIX_PROMPT="$FIX_PROMPT"
        fi

        # Âæ™ÁéØÊâßË°å‰ªéËµ∑ÂßãÊ≠•È™§ÂºÄÂßãÁöÑÊâÄÊúâÊ≠•È™§
        while [[ $current_idx -lt ${#STEPS[@]} ]]; do
            local step="${STEPS[$current_idx]}"
            local step_num=$((current_idx + 1))
            
            case "$step" in
                "PLAN")
                    run_step "$step_num" "$step" "$CONTEXT

$ACTIVE_PLAN_PROMPT" "Analyzing..." "$i"
                    local error_code=$(jq -r '.errorCode' $ZHIREN_CURRENT_STEP_FILE)
                    # PLAN Ê≠•È™§ÁöÑÁâπÊÆäÊ£ÄÊü•
                    if [[ "$error_code" == "TASK_NOT_GENERATED" ]]; then
                        break  # Ëøô‰ºöË∑≥Âá∫ while Âæ™ÁéØ
                    fi
                    ;;
                    
                "EXECUTE")
                    run_step "$step_num" "$step" "$CONTEXT

$ACTIVE_EXECUTE_PROMPT" "Implementing..." "$i"
                    ;;
                    
                "REVIEW")
                    run_step "$step_num" "$step" "$CONTEXT

$ACTIVE_REVIEW_PROMPT" "Reviewing..." "$i"
                    ;;
                    
                "FIX")
                    run_step "$step_num" "$step" "$CONTEXT

$ACTIVE_FIX_PROMPT" "Fixing..." "$i"
                    ;;
            esac
            
            ((current_idx++))  # ÁßªÂä®Âà∞‰∏ã‰∏ÄÊ≠•
        done

        sleep 2
    done

    log "LIGHT" "Max iterations reached ($MAX_ITERATIONS) - exiting main loop"
}

main_loop